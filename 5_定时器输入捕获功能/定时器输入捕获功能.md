# 定时器输入捕获功能

# 输入捕获功能概述

## 输入**捕获功能的用途和工作原理**

- 用途：用于测量信号的参数，比如周期和频率。
- 工作原理：在输入捕获模式下，当捕获单元捕捉到外部信号的有效边沿(上升沿/下降 沿/双边沿)时，将计数器的当前值锁存到捕获/比较寄存器TIMx_CCR， 供用户读取。

## 捕获通道的内部结构

![Untitled](%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%8A%9F%E8%83%BD/Untitled.png)

## **捕获过程示意图**

![Untitled](%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%8A%9F%E8%83%BD/Untitled%201.png)

**将两次捕获值相减，再乘以计数时间可计算出信号周期**

## **信号参数计算公式**

$$
\text{Period(s)}=\dfrac{\text{Diff}\times\text{(PSC+1)}}{\text{TIM\_CLK}}
$$

$$
\text{Freq(Hz)}=\dfrac{\text{TIM\_CLK}}{\text{Diff}\times\text{(PSC+1)}}
$$

当待测信号不大于定时器的一个完整计数周期(从0到ARR)时。假设两次连续的捕获值分别为CCRx_1 和 CCRx_2，则捕获差值可以按照如下方法计算：

- 如果 CCRx_1 < CCRx_2： 捕获差值 = CCRx_2 - CCRx_1
- 如果 CCRx_1 > CCRx_2： 捕获差值 = (ARR + 1 - CCRx_1) + CCRx_2

注意：如果待测信号大于定时器的一个完整计数周期，则需要结合定时器的更新中断次数来计算捕获差值。

## 输入捕获功能的数据类型和接口函数

![Untitled](%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%8A%9F%E8%83%BD/Untitled%202.png)

**成员变量ICPolarity的取值范围**

| 宏常量定义 | 含义 |
| --- | --- |
| TIM_ICPOLARITY_RISING | 上升沿捕获 |
| TIM_ICPOLARITY_FALLING | 下降沿捕获 |
| TIM_ICPOLARITY_BOTHEDGE | 双边沿捕获 |

**成员变量ICSelection的取值范围**

| 宏常量定义 | 含义 |
| --- | --- |
| TIM_ICSELECTION_DIRECTTI | 直接输入模式：
捕获通道CH1和CH2分别与IC1和IC2连接
捕获通道CH3和CH4分别与IC3和IC4连接 |
| TIM_ICSELECTION_DIRECTT2 | 间接输入模式：
捕获通道CH1和CH2分别与IC2和IC1连接
捕获通道CH3和CH4分别与IC4和IC3连接 |
| TIM_ICSELECTION_TRC | 选择从模式管理器的触发信号TRC 作获信号 |

**成员变量ICPrescaler的取值范围**

| 宏常量定义 | 含义 |
| --- | --- |
| TIM_ICPSC_DIV1 | 检测到输入信号的每1个有效边沿触发1次捕获 |
| TIM_ICPSC_DIV2 | 检测到输入信号的每2个有效边沿触发1次捕获 |
| TIM_ICPSC_DIV3 | 检测到输入信号的每4个有效边沿触发1次捕获 |
| TIM_ICPSC_DIV4 | 检测到输入信号的每8个有效边沿触发1次捕获 |
1. **输入捕获启动函数： `HAL_TIM_IC_Start_IT`**
   
   
    | 函数原型 | uint32_t  HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel) |
    | --- | --- |
    | 功能描述 | 用于在中断方式下启动定时器的输入捕获功能 |
    | 入口参数 | htim：定时器句柄的地址
    Channel：定时器通道号，  取值范围是TIM_CHANNEL_1~TIM_CHANNEL_4 |
    | 返回值 | HAL状态值 |
    | 注意事项 | 1. 该函数在定时器初始化完成之后调用
    2. 函数需要由用户调用，用于使能定时器的捕获中断，并启动定时器运行 |
2. **输入捕获停止函数：`HAL_TIM_IC_Stop_IT`**
   
   
    | 函数原型 | HAL_StatusTypeDef  HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel) |
    | --- | --- |
    | 功能描述 | 用于停止在中断方式下定时器的输入捕获功能 |
    | 入口参数 | htim：定时器句柄的地址
    Channel：定时器通道号，  取值范围是TIM_CHANNEL_1~TIM_CHANNEL_4 |
    | 返回值 | HAL状态值 |
    | 注意事项 | 1. 该函数需要由用户调用，用于禁止捕获中断，关闭输入捕获通道，停止 定时器运行 |
3. **输入捕获中断回调函数：`HAL_TIM_IC_CaptureCallback`**
   
   
    | 函数原型 | void HAL_TIM_IC_CaptureCallback (TIM_HandleTypeDef *htim) |
    | --- | --- |
    | 功能描述 | 用于处理所有定时器的输入捕获中断，用户在该函数内编写实际的任务处理程序 |
    | 入口参数 | htim：定时器句柄的地址 |
    | 返回值 | 无 |
    | 注意事项 | 1. 该函数由定时器中断通用处理函数HAL_TIM_IRQHandler调用，完成所 有定时器输入捕获中断的任务处理
    2. 函数内部需要根据定时器句柄的实例来判断是哪一个定时器的哪一个通道 产生的本次输入捕获中断
    3. 函数由用户根据具体的处理任务编写 |
4. **捕获值读取函数：`HAL_TIM_ReadCapturedValue`**
   
   
    | 函数原型 | uint32_t  HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel) |
    | --- | --- |
    | 功能描述 | 用于处理所有定时器的输入捕获中断，用户在该函数内编写实际的任务处理程序 |
    | 入口参数 | htim：定时器句柄的地址
    Channel：定时器通道号，  取值范围是TIM_CHANNEL_1~TIM_CHANNEL_4 |
    | 返回值 | 捕获值 |
    | 注意事项 | 1. 函数需要由用户调用，用于读取发生捕获时的捕获值 |
5. **捕获边沿设置函数： `__HAL_TIM_SET_CAPTUREPOLARITY`**
   
   
    | 函数原型 | __HAL_TIM_SET_CAPTUREPOLARITY(__HANDLE__,   __CHANNEL__, __POLARITY__ |
    | --- | --- |
    | 功能描述 | 用于设置输入信号的捕获边沿 |
    | 入口参数 | __HANDLE__： 定时器句柄的地址
    __Channel__：定时器通道号，  取值范围是TIM_CHANNEL_1~TIM_CHANNEL_4
    __POLARITY__ ：捕获边沿， 取值范围是TIM_INPUTCHANNELPOLARITY_RISING/FALLING/BOTHEDGE |
    | 返回值 | 无 |
    | 注意事项 | 1. 该函数是宏函数，进行宏替换，不发生函数调用
    2. 函数需要由用户调用，用于设置输入信号的有效捕获边沿 |

# 任务实践

利用定时器2的通道1(对应引脚PA0)来测量一个外部脉冲信号的周期和频率，外部脉冲信号利用引脚PA6输入。

1. 配置定时器2时钟源为内部时钟源（8MHz），通道一为输入捕获方式。
   
    配置时基单元
    
    1. 预分频系数PSC为0，即计数时钟CK_CNT为8MHz，便于扩大测量频率的范围。
    2. 设置自动重载值ARR为最长的计数周期，便于扩大测量频率的脉宽。
    
    配置输入捕获通道采用默认参数
    
    1. 捕获有效边沿为上升沿
    2. 捕获通道为直接输入方式
    3. 捕获信号不分频
    4. 捕获信号不进行滤波
    
    ![Untitled](%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%8A%9F%E8%83%BD/Untitled%203.png)
    
    使能定时器2的全局中断，中断优先级使用默认值
    
    ![Untitled](%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%8A%9F%E8%83%BD/Untitled%204.png)
    
2. 配置定时器3时钟源为内部时钟源（8MHz），通道一为PWM输出模式。
   
    设置预分频系数PSC为399，自动重载值 ARR为199，表示PWM信号的周期为10ms。
    
    设置捕获/比较值CRR为100， 表示PWM信号的占空比为50%
    
    ![Untitled](%E5%AE%9A%E6%97%B6%E5%99%A8%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E5%8A%9F%E8%83%BD/Untitled%205.png)
    
3. 打开串口USART1，并在工程中添加头文件和prinrf函数重定义，Keil中勾选USE MicroLIB。
4. 编写程序
   
    ```c
    /* USER CODE BEGIN PV */
    uint32_t Diff       = 0;   // 存放捕获差值
    uint32_t Period     = 0;   // 存放计算所得周期
    uint8_t MeasureFlag = 0;   // 测量完成标志：  0表示未完成，  1表示完成
    uint8_t CapIndex    = 0;   // 捕获指示：  0表示没有开始捕获，  1表示完成一次捕获
    uint32_t CapVal1    = 0;   // 存放第一次捕获值
    uint32_t CapVal2    = 0;   // 存放第二次捕获值
    /* USER CODE END PV */
    
    /* USER CODE BEGIN 2 */
      printf("Timer Capture Function Test: \n");
      HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);
      HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
      /* USER CODE END 2 */
    
    		/* USER CODE BEGIN 3 */
        if(MeasureFlag == 1) 
        {
          if(CapVal2 >=  CapVal1)
          {
            Diff = CapVal2 -  CapVal1;
          }
          else
          {
            Diff = ((65535 + 1 - CapVal1) + CapVal2) ;
          }
        }
        Period = Diff/20000;
        printf ("Period    is: %.4fms\r\n", Diff/20000.0);
        printf ("Frequency is: %dHz\r\n", 8000000/Period);
        printf ("/*****************/\r\n");
        MeasureFlag = 0;
        HAL_Delay(1000);
        HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);
      }
      /* USER CODE END 3 */
    
    /* USER CODE BEGIN 4 */
    int fputc (int ch, FILE *f)
    {
        HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
        return ch;
    }
    
    int fgetc(FILE *f)
    {
        uint8_t ch = 0;
        HAL_UART_Receive(&huart1, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
        return ch;
    }
    
    void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
    {
      if (htim->Instance == TIM2)
      {
        if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
        {
          if (CapIndex == 0)
          {
            CapVal1 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
            CapIndex = 1;
          }
          if (CapIndex == 1)
          {
            CapVal2 = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
            CapIndex = 0;
            MeasureFlag = 1;
          }
          else
          {
            Error_Handler();
          }
        }
      }
    }
    /* USER CODE END 4 */
    ```